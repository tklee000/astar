# A* 길찾기 알고리즘

BFS(너비우선탐색) 알고리즘과 다른점이 목표점이 제시되었을 경우 적어도 어느 방향으로 가면 목표점으로 빨리갈수 있는가?
목표점에 도달하기 위한 비용을 대충 어림짐작으로 계산할 수 있는 상태에서는 A* 알고리즘을 이용해서 검색 우선 순위를 인위적으로 조정해서 검색의 효율성을 높힐 수 있다.
BFS가 물을 부으면 마치 점점 물이 번지듯이 검색대상을 원을 점점 넓히며 목표점을 찾아내는것과 기본적인 구조는 동일하다. 하지만 A* 알고리즘은 2가지가 추가된다.
첫번째, 생성된 자식 노드를 Queue에서 pop하는 과정에서 목표점 방향으로 가까운 방향의 자식노드를 우선 선택 (비용이 적게 드는 노드)
두번째, 트리를 방문하고 자식노드 생성 과정에서 이전에 셀에 비용값을 기록해 두어서 새로 계산된 비용이 과거셀에 적어둔 비용보다 적은 경우만 자식노드를 확장
이렇게 BFS의 탐색 범위를 비용을 이용해서 줄이고 여기서 만들어진 경로는 최단 경로가 된다.

A* 알고리즘

구현하기는 정말 쉽다~ 하지만 어떻게 이런 기발한 아이디어를 이해하는가는 별개의 문제 ^^;

```
F = G + H
G = 시작노드부터 현재노드까지 총 Cost 한칸 진행할때마다 비용이 1이며 이러한 값을 쭉 누적시킨다.
H = 현재노드부터 목표노드까지 총 Cost 일단 앞으로의 진행길을 모르기 때문에 그냥 목표점까지 벽뚫고 직선을 추정한 길이~

F = 목표점까지 가는 총Cost이다...쉽게 말해서 지나온 비용 + 지나길 비용 을 합산한 값이며,
최단거리로 향할 경우보다 당연히 둘러서가서 가는 경우가 비용이 커진다.
```

현재의 좌표에서 진행 가능한 다음 셀의 비용을 계산한 후 오픈리스트에 추가한다.
동서남북 4방향이 뚤려있다면 오픈리스트에 처음 4개가 추가시킨다.
오픈리스트는 우선순위큐(priority_queue)를 이용하는데 배열은 항상 적은 값 기준으로 정렬되기 때문에
추가된 노드중에서 비용을 가장적은 노드를 우선적으로 꺼내서 다음 단계를 처리할수 있게 된다.

오픈리스트 큐에서 노드를 하나 꺼낸후 노드의 좌표를 현재점으로 한 후 새로 진행한 노드에서 진행 가능한 방향의 비용을 계산한 후 탐색 노드를 추가한다.
이전에 현재 처리되는 좌표는 방문처리를 미리해두어서 지나온 곳은 또다시 계산하지 않는다. 
지나온 곳을 제외시켜서 나머지 3곳을 노드가 살펴본다.

참고로) 이미 지나온곳은 셀에서 visit에 true 값을 대입해서 제외 시킬것인지 여부를 확인할 수 있다. 일반적으로 CloseList를 별도로 관리하는게 정석이지만
BFS처럼 그냥 셀의 visit 플랙으로 대체가능하다.

살펴보는 셀의 f 값이 무한대인 경우는 최초로 살펴보는 셀이기 때문에 무조건 오픈리스트에 추가한다.
바로 직전 노드에서도 4방향을 살폈기 때문에 이전 단계에서 계산된 셀을 참조하는 경우도 있는데 
만약에 지금의 f 가 더 작다면 셀의 내용을 갱신하고 오픈리스트에 추가한다.

탐색하면서 셀의 F,G,H, 부모X,부모Y 값은 계속 비용이 적은 상태로 셀의 내용을 갱신해놓는다.
셀은 어느 부터 부모 셀로부터 왔는가와 시작점부터 누적된 g 값이 누적되어 있다.
여기서 과거 셀의 f 보다 지금의 f 가 큰경우는 오픈리스트에 추가하지 않는 이유는 
전에 살펴본 지점이며 그쪽으로 가는경우는 오히려 돌아가야 하는 상황이라 오픈리스트에 추가하지 않는다.

그리고 오픈리스트 큐에서 최상위 노드를 꺼내서(pop) 위의 과정을 반복한다.
오픈리스트 큐에서 최상위 노드를 꺼내는것은 우선순위큐 사용으로 자동으로 비용이 가장 적은 녀석을 우선적으로 꺼내진다. 그래서 가장 빠른 노드로 한단계식 진행할 수 있도록 해준다.
더이상 자식노드를 추가하지 못하는 경우는 진행방향이 막히는 경우이며 이전 단계에서 추가된 자식 노드를 팝해서 처리된다.
